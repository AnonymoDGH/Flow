```python
import numpy as np
import matplotlib.pyplot as plt
import time

print("="*60)
print("FLOW ML - GENERADOR DE FORMAS GEOMETRICAS")
print("Comparacion: Primera vs Ultima generacion")
print("="*60)

# Configuración
IMG_SIZE = 28
NUM_CLASSES = 3
BATCH_SIZE = 32
MAX_EPOCHS = 1000

# Generar datos de formas
def generate_shape(shape_type, seed=None):
    if seed is not None:
        np.random.seed(seed)
    
    img = np.zeros((IMG_SIZE, IMG_SIZE))
    
    if shape_type == 0:  # Cuadrado
        size = np.random.randint(8, 20)
        x = np.random.randint(2, IMG_SIZE - size - 2)
        y = np.random.randint(2, IMG_SIZE - size - 2)
        img[y:y+size, x:x+size] = 1
        
    elif shape_type == 1:  # Triangulo
        size = np.random.randint(10, 22)
        x = np.random.randint(2, IMG_SIZE - size - 2)
        y = np.random.randint(2, IMG_SIZE - size - 2)
        for i in range(size):
            start = x + i // 2
            end = x + size - i // 2
            img[y + i, start:end] = 1
            
    elif shape_type == 2:  # Circulo
        radius = np.random.randint(5, 12)
        cx = np.random.randint(radius + 2, IMG_SIZE - radius - 2)
        cy = np.random.randint(radius + 2, IMG_SIZE - radius - 2)
        y, x = np.ogrid[:IMG_SIZE, :IMG_SIZE]
        mask = (x - cx)**2 + (y - cy)**2 <= radius**2
        img[mask] = 1
    
    noise = np.random.normal(0, 0.1, (IMG_SIZE, IMG_SIZE))
    img = np.clip(img + noise, 0, 1)
    
    return img.flatten()

# Red neuronal
class SimpleNN:
    def __init__(self):
        self.W1 = np.random.randn(IMG_SIZE * IMG_SIZE, 64) * 0.01
        self.b1 = np.zeros((1, 64))
        self.W2 = np.random.randn(64, 32) * 0.01
        self.b2 = np.zeros((1, 32))
        self.W3 = np.random.randn(32, NUM_CLASSES) * 0.01
        self.b3 = np.zeros((1, NUM_CLASSES))
        
    def relu(self, x):
        return np.maximum(0, x)
    
    def softmax(self, x):
        exp_x = np.exp(x - np.max(x, axis=1, keepdims=True))
        return exp_x / np.sum(exp_x, axis=1, keepdims=True)
    
    def forward(self, X):
        self.z1 = np.dot(X, self.W1) + self.b1
        self.a1 = self.relu(self.z1)
        self.z2 = np.dot(self.a1, self.W2) + self.b2
        self.a2 = self.relu(self.z2)
        self.z3 = np.dot(self.a2, self.W3) + self.b3
        self.a3 = self.softmax(self.z3)
        return self.a3
    
    def backward(self, X, y, learning_rate=0.01):
        m = X.shape[0]
        y_onehot = np.zeros((m, NUM_CLASSES))
        y_onehot[np.arange(m), y] = 1
        
        dz3 = self.a3 - y_onehot
        dW3 = np.dot(self.a2.T, dz3) / m
        db3 = np.sum(dz3, axis=0, keepdims=True) / m
        
        da2 = np.dot(dz3, self.W3.T)
        dz2 = da2 * (self.a2 > 0)
        dW2 = np.dot(self.a1.T, dz2) / m
        db2 = np.sum(dz2, axis=0, keepdims=True) / m
        
        da1 = np.dot(dz2, self.W2.T)
        dz1 = da1 * (self.a1 > 0)
        dW1 = np.dot(X.T, dz1) / m
        db1 = np.sum(dz1, axis=0, keepdims=True) / m
        
        self.W3 -= learning_rate * dW3
        self.b3 -= learning_rate * db3
        self.W2 -= learning_rate * dW2
        self.b2 -= learning_rate * db2
        self.W1 -= learning_rate * dW1
        self.b1 -= learning_rate * db1

# Generar primeras imágenes (época 1)
print("\n[Generando primeras imagenes...]")
first_square = generate_shape(0, seed=42).reshape(IMG_SIZE, IMG_SIZE)
first_triangle = generate_shape(1, seed=43).reshape(IMG_SIZE, IMG_SIZE)
first_circle = generate_shape(2, seed=44).reshape(IMG_SIZE, IMG_SIZE)

# Inicializar modelo
model = SimpleNN()
losses = []
accuracies = []
start_time = time.time()

print(f"\n[Entrenando por {MAX_EPOCHS} epocas...]")
print("Progreso: ", end="", flush=True)

# Entrenamiento
for epoch in range(1, MAX_EPOCHS + 1):
    # Generar batch
    X_batch = []
    y_batch = []
    for _ in range(BATCH_SIZE):
        shape_type = np.random.randint(0, NUM_CLASSES)
        img = generate_shape(shape_type)
        X_batch.append(img)
        y_batch.append(shape_type)
    
    X_batch = np.array(X_batch)
    y_batch = np.array(y_batch)
    
    # Forward y backward
    predictions = model.forward(X_batch)
    model.backward(X_batch, y_batch, learning_rate=0.1)
    
    # Métricas
    loss = -np.mean(np.log(predictions[np.arange(BATCH_SIZE), y_batch] + 1e-10))
    pred_classes = np.argmax(predictions, axis=1)
    accuracy = np.mean(pred_classes == y_batch) * 100
    
    losses.append(loss)
    accuracies.append(accuracy)
    
    # Mostrar progreso
    if epoch % 100 == 0:
        print(f"{epoch}...", end="", flush=True)

print(" Completado!")

# Generar últimas imágenes (época 1000)
print("\n[Generando ultimas imagenes...]")
last_square = generate_shape(0, seed=42).reshape(IMG_SIZE, IMG_SIZE)
last_triangle = generate_shape(1, seed=43).reshape(IMG_SIZE, IMG_SIZE)
last_circle = generate_shape(2, seed=44).reshape(IMG_SIZE, IMG_SIZE)

# Calcular estadísticas finales
total_time = time.time() - start_time
final_loss = losses[-1]
final_acc = accuracies[-1]
best_acc = max(accuracies)
avg_loss = np.mean(losses[-100:])

# Crear visualización
print("\n[Creando visualizacion...]")
fig = plt.figure(figsize=(16, 10))
fig.suptitle('Flow ML - Comparacion de Generacion de Formas (Epoca 1 vs Epoca 1000)', 
             fontsize=16, fontweight='bold')

# Fila 1: Primera generación
ax1 = plt.subplot(3, 3, 1)
ax1.imshow(first_square, cmap='viridis')
ax1.set_title('CUADRADO - Epoca 1', fontsize=12, fontweight='bold')
ax1.axis('off')

ax2 = plt.subplot(3, 3, 2)
ax2.imshow(first_triangle, cmap='viridis')
ax2.set_title('TRIANGULO - Epoca 1', fontsize=12, fontweight='bold')
ax2.axis('off')

ax3 = plt.subplot(3, 3, 3)
ax3.imshow(first_circle, cmap='viridis')
ax3.set_title('CIRCULO - Epoca 1', fontsize=12, fontweight='bold')
ax3.axis('off')

# Fila 2: Última generación
ax4 = plt.subplot(3, 3, 4)
ax4.imshow(last_square, cmap='plasma')
ax4.set_title('CUADRADO - Epoca 1000', fontsize=12, fontweight='bold')
ax4.axis('off')

ax5 = plt.subplot(3, 3, 5)
ax5.imshow(last_triangle, cmap='plasma')
ax5.set_title('TRIANGULO - Epoca 1000', fontsize=12, fontweight='bold')
ax5.axis('off')

ax6 = plt.subplot(3, 3, 6)
ax6.imshow(last_circle, cmap='plasma')
ax6.set_title('CIRCULO - Epoca 1000', fontsize=12, fontweight='bold')
ax6.axis('off')

# Fila 3: Métricas
ax7 = plt.subplot(3, 3, 7)
ax7.plot(losses, 'b-', linewidth=2, alpha=0.7)
ax7.set_title('Loss durante entrenamiento', fontsize=11, fontweight='bold')
ax7.set_xlabel('Epoca')
ax7.set_ylabel('Loss')
ax7.grid(True, alpha=0.3)

ax8 = plt.subplot(3, 3, 8)
ax8.plot(accuracies, 'g-', linewidth=2, alpha=0.7)
ax8.set_title('Accuracy durante entrenamiento', fontsize=11, fontweight='bold')
ax8.set_xlabel('Epoca')
ax8.set_ylabel('Accuracy (%)')
ax8.set_ylim([0, 100])
ax8.grid(True, alpha=0.3)

ax9 = plt.subplot(3, 3, 9)
ax9.axis('off')
stats_text = f"""
RESULTADOS DEL ENTRENAMIENTO

Epocas completadas: {MAX_EPOCHS}
Tiempo total: {total_time:.2f}s
Tiempo/epoca: {total_time/MAX_EPOCHS*1000:.1f}ms

Loss inicial: {losses[0]:.4f}
Loss final: {final_loss:.4f}
Mejora: {((losses[0]-final_loss)/losses[0]*100):.1f}%

Accuracy inicial: {accuracies[0]:.1f}%
Accuracy final: {final_acc:.1f}%
Mejor accuracy: {best_acc:.1f}%

Muestras procesadas: {MAX_EPOCHS * BATCH_SIZE}
Velocidad: {MAX_EPOCHS/total_time:.1f} epocas/s
"""

ax9.text(0.1, 0.5, stats_text, fontsize=10, 
        verticalalignment='center', family='monospace',
        bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))

plt.tight_layout()

# Guardar imagen
output_file = 'flow_ml_shapes_comparison.png'
plt.savefig(output_file, dpi=150, bbox_inches='tight')
print(f"\n[Imagen guardada como: {output_file}]")

# Mostrar
plt.show()

# Resumen en consola
print("\n" + "="*60)
print("RESUMEN FINAL")
print("="*60)
print(f"\nEntrenamiento completado en {total_time:.2f}s")
print(f"Epocas: {MAX_EPOCHS}")
print(f"Velocidad: {MAX_EPOCHS/total_time:.1f} epocas/segundo")
print(f"\nLoss: {losses[0]:.4f} -> {final_loss:.4f} (mejora: {((losses[0]-final_loss)/losses[0]*100):.1f}%)")
print(f"Accuracy: {accuracies[0]:.1f}% -> {final_acc:.1f}% (mejor: {best_acc:.1f}%)")
print(f"\nMuestras procesadas: {MAX_EPOCHS * BATCH_SIZE:,}")
print("\n" + "="*60)
```
